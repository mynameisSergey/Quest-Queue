# Quest-Queue

![](https://github.com/mynameisSergey/java-kanban/blob/main/img/%D0%A1%D1%85%D0%B5%D0%BC%D0%B0.png)

## Техническое задание
Вернуться к работе над менеджером задач. Основная логика приложения реализована, теперь можно сделать для него API.
Настроить доступ к методам менеджера через HTTP-запросы.

### Прорабатываем логику API
Реализовал API, где эндпоинты соответствуют вызовам базовых методов интерфейса TaskManager.

Сначала добавил в проект библиотеку Gson для работы с JSON. Далее создал класс HttpTaskServer, который слушает
порт 8080 и принимает запросы. Добавил в него реализацию FileBackedTaskManager, которую можно получить из утилитного
класса Managers. После этого можно реализовать маппинг запросов на методы интерфейса TaskManager.

API работает так, что все запросы по пути /tasks/<ресурсы> приходят в интерфейс TaskManager. Путь для обычных
задач — /tasks/task, для подзадач — /tasks/subtask, для эпиков — /tasks/epic. Получить все задачи сразу можно по
пути /tasks/, а получить историю задач по пути /tasks/history.

Для получения данных созданы GET-запросы. Для создания и изменения — POST-запросы. Для удаления — DELETE-запросы.
Задачи передаются в теле запроса в формате JSON. Идентификатор (id) задачи следует передавать параметром запроса (через
вопросительный знак).

В результате для каждого метода интерфейса TaskManager создан отдельный эндпоинт, который можно
вызвать по HTTP.

### Как проверить эндпоинты
Проверить API можно несколькими способами.
Через Insomnia.
С помощью плагина для браузера, к примеру, RESTED, Postman, RESTClient или других.
В IDEA через шаблоны HTTP-запросов — scratch file. Нажмите комбинацию CTRL+SHIFT+ALT+Insert и выберите HTTP Request.

### HTTP-сервер для хранения задач
Раньше задачи хранились в файлах. Теперь перенес их на сервер. Для этого написали HTTP-клиент. С его помощью 
переместил хранение состояния менеджера из файлов на отдельный сервер.

### HTTP-клиент
Для работы с хранилищем потребовался HTTP-клиент, который делегирует вызовы методов в HTTP-запросы.

При создании KVTaskClient учел следующее:
Конструктор принимает URL к серверу хранилища и регистрируется. При регистрации выдаётся токен (API_TOKEN), который
нужен при работе с сервером.
Метод void put(String key, String json) сохраняет состояние менеджера задач через запрос
POST /save/<ключ>?API_TOKEN=.
Метод String load(String key) возвращает состояние менеджера задач через запрос GET /load/<ключ>?API_TOKEN=.

### Новая реализация менеджера задач
Теперь можно создать новую реализацию интерфейса TaskManager — класс HTTPTaskManager. Он наследуется от
FileBackedTasksManager.

Конструктор HTTPTaskManager вместо имени файла принимает URL к серверу KVServer. Также HTTPTaskManager
создаёт KVTaskClient, из которого можно получить исходное состояние менеджера. Заменил вызовы сохранения
состояния в файлах на вызов клиента.

В конце обновили статический метод getDefault() в утилитарном классе Managers, чтобы он возвращал HTTPTaskManager.

### Тестирование
Код проверки в Main.main перестал работать. Это произошло, потому что Managers.getDefault() теперь возвращает новую
реализацию менеджера задач, а она не может работать без запуска сервера. 

Для этого добавил запуск KVServer в Main.main и перезапустил пример использования менеджера. Всё работает и
состояние задач теперь хранится на сервере.

Добавил тесты для HTTPTaskManager аналогично тому, как сделал для FileBackedTasksManager, отличие только в том, что
вместо проверки восстановления состояния менеджера из файла, данные будут восстанавливаться с KVServer сервера.

Написал тесты для каждого эндпоинта HTTPTaskServer. Чтобы каждый раз не добавлять запуск KVServer и HTTPTaskServer
серверов. 

Ура! Теперь приложение доступно по HTTP и умеет хранить своё состояние на отдельном сервере!