# java-kanban


## Техническое задание
Возвращаемся к работе над менеджером задач. Основная логика приложения реализована, теперь можно сделать для него API.
Настраиваем доступ к методам менеджера через HTTP-запросы.

### Прорабатываем логику API
Реализовали API, где эндпоинты соответствуют вызовам базовых методов интерфейса TaskManager.
Соответствие эндпоинтов и методов называется маппингом. Вот как это должно будет выглядеть.

Сначала добавили в проект библиотеку Gson для работы с JSON. Далее создали класс HttpTaskServer, который слушает
порт 8080 и принимает запросы. Добавили в него реализацию FileBackedTaskManager, которую можно получить из утилитного
класса Managers. После этого можно реализовали маппинг запросов на методы интерфейса TaskManager.

API работает так, что все запросы по пути /tasks/<ресурсы> приходят в интерфейс TaskManager. Путь для обычных
задач — /tasks/task, для подзадач — /tasks/subtask, для эпиков — /tasks/epic. Получить все задачи сразу можно по
пути /tasks/, а получить историю задач по пути /tasks/history.

Для получения данных созданы GET-запросы. Для создания и изменения — POST-запросы. Для удаления — DELETE-запросы.
Задачи передаются в теле запроса в формате JSON. Идентификатор (id) задачи следует передавать параметром запроса (через
вопросительный знак).

В результате для каждого метода интерфейса TaskManager создан отдельный эндпоинт, который можно
вызвать по HTTP.

### Как проверить эндпоинты
Проверить API можно несколькими способами.
Через Insomnia.
С помощью плагина для браузера, к примеру, RESTED, Postman, RESTClient или других.
В IDEA через шаблоны HTTP-запросов — scratch file. Нажмите комбинацию CTRL+SHIFT+ALT+Insert и выберите HTTP Request.

### HTTP-сервер для хранения задач
Раньше задачи хранились в файлах. Теперь перенесли их на сервер. Для этого написали HTTP-клиент. С его помощью мы
переместили хранение состояния менеджера из файлов на отдельный сервер.

### HTTP-клиент
Для работы с хранилищем нам потребовался HTTP-клиент, который делегирует вызовы методов в HTTP-запросы.

При создании KVTaskClient учли следующее:
Конструктор принимает URL к серверу хранилища и регистрируется. При регистрации выдаётся токен (API_TOKEN), который
нужен при работе с сервером.
Метод void put(String key, String json) сохраняет состояние менеджера задач через запрос
POST /save/<ключ>?API_TOKEN=.
Метод String load(String key) возвращает состояние менеджера задач через запрос GET /load/<ключ>?API_TOKEN=.

### Новая реализация менеджера задач
Теперь можно создать новую реализацию интерфейса TaskManager — класс HTTPTaskManager. Он наследуется от
FileBackedTasksManager.

Конструктор HTTPTaskManager вместо имени файла принимает URL к серверу KVServer. Также HTTPTaskManager
создаёт KVTaskClient, из которого можно получить исходное состояние менеджера. Заменили вызовы сохранения
состояния в файлах на вызов клиента.

В конце обновили статический метод getDefault() в утилитарном классе Managers, чтобы он возвращал HTTPTaskManager.

### Тестирование
Код проверки в Main.main перестал работать. Это произошло, потому что Managers.getDefault() теперь возвращает новую
реализацию менеджера задач, а она не может работать без запуска сервера. 

Для этого добавили запуск KVServer в Main.main и перезапустили пример использования менеджера. Всё работает и
состояние задач теперь хранится на сервере.

Добавили тесты для HTTPTaskManager аналогично тому, как сделали для FileBackedTasksManager, отличие только,
вместо проверки восстановления состояния менеджера из файла, данные будут восстанавливаться с KVServer сервера.

Написали тесты для каждого эндпоинта HTTPTaskServer. Чтобы каждый раз не добавлять запуск KVServer и HTTPTaskServer
серверов. 

Ура! Теперь наше приложение доступно по HTTP и умеет хранить своё состояние на отдельном сервере!